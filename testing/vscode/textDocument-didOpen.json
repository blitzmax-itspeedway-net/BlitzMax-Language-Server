{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///home/si/dev/LSP/lsp.bmx","languageId":"blitzmax","version":1,"text":"SuperStrict\r\n\r\n'   LANGUAGE SERVER EXTENSION FOR BLITZMAX NG\r\n'   (c) Copyright Si Dunford, June 2021, All Right Reserved\r\n\r\nFramework brl.standardio \r\nImport brl.collections      ' Used for Tokeniser\r\n'Import brl.linkedlist\r\nImport brl.map              ' Used as JSON dictionary\r\nImport brl.reflection\t\t' USed by JSON.transpose\r\nImport brl.retro\r\nImport brl.stringbuilder\r\nImport brl.system\r\nImport brl.threads\r\nImport brl.threadpool\r\n\r\nImport pub.freeprocess\r\n'debugstop\r\n'   INCLUDE APPLICATION COMPONENTS\r\n\r\n'DebugStop\r\n\r\nInclude \"bin/TObserver.bmx\"\r\nInclude \"bin/TMessageQueue.bmx\"\r\nInclude \"bin/TConfig.bmx\"\r\nInclude \"bin/TLogger.bmx\"\r\n'Include \"bin/TTemplate.bmx\"    ' Depreciated (Functionality moved into JSON)\r\nInclude \"bin/json.bmx\"\r\n\r\nInclude \"bin/sandbox.bmx\"\r\n\r\nInclude \"handlers/handlers.bmx\"\r\n\r\n' RPC2.0 Error Messages\r\nConst ERR_PARSE_ERROR:String =       \"-32700\"  'Invalid JSON was received by the server.\r\nConst ERR_INVALID_REQUEST:String =   \"-32600\"  'The JSON sent is not a valid Request object.\r\nConst ERR_METHOD_NOT_FOUND:String =  \"-32601\"  'The method does not exist / is not available.\r\nConst ERR_INVALID_PARAMS:String =    \"-32602\"  'Invalid method parameter(s).\r\nConst ERR_INTERNAL_ERROR:String =    \"-32603\"  'Internal JSON-RPC error.\r\n\r\n' LSP Error Messages\r\nConst ERR_SERVER_NOT_INITIALIZED:String = \"-32002\"\r\nConst ERR_CONTENT_MODIFIED:String =       \"-32801\"\r\nConst ERR_REQUEST_CANCELLED:String =      \"-32800\"\r\n\r\n?win32\r\n    Const EOL:String = \"~n\"\r\n?Not win32\r\n    Const EOL:String = \"~r~n\"\r\n?\r\n\r\n'   GLOBALS\r\nAppTitle = \"Language Server for BlitzMax NG\"\r\nGlobal DEBUGGER:Int = False\r\n\r\n'DebugStop\r\n'Global Version:String = \"0.00 Pre-Alpha\"\r\nLocal Logfile:TLogger = New TLogger()         ' Please use Observer\r\nGlobal LSP:TLSP\r\n\r\n'   DEBUG THE COMMAND LINE\r\nPublish \"log\", \"DEBG\", \"ARGS: (\"+AppArgs.length+\")\"     '+(\" \".join(AppArgs))\r\nFor Local n:Int=0 Until AppArgs.length\r\n    Publish \"log\", \"DEBG\", n+\") \"+AppArgs[n]\r\nNext\r\nPublish \"log\", \"DEBG\", \"CURRENTDIR: \"+CurrentDir$()\r\nPublish \"log\", \"DEBG\", \"APPDIR:     \"+AppDir\r\n\r\n'   INCREMENT BUILD NUMBER\r\n\r\n' @bmk include build.bmk\r\n' @bmk incrementVersion build.bmx\r\nInclude \"build.bmx\"\r\nPublish \"log\", \"INFO\", AppTitle\r\nPublish \"log\", \"INFO\", \"Version \"+version+\".\"+build\r\n\r\n'   MAIN APPLICATION\r\n\r\n'DebugStop\r\nType TLSP Extends TObserver\r\n    Global instance:TLSP\r\n\r\n    Field exitcode:Int = 0\r\n\r\n\tField initialized:Int = False   ' Set by \"iniialized\" message\r\n    Field shutdown:Int = False      ' Set by \"shutdown\" message\r\n    Field QuitMain:Int = True       ' Atomic State - Set by \"exit\" message\r\n\r\n    Field queue:TMessageQueue = New TMessageQueue()\r\n\r\n\t' Create a document manager\r\n\tField textDocument:TTextDocument\t' Do not initialise here: Depends on lsp.\r\n\r\n    ' Threads\r\n    Field Receiver:TThread\r\n    Field QuitReceiver:Int = True   ' Atomic State\r\n    Field Sender:TThread\r\n    Field QuitSender:Int = True     ' Atomic State\r\n    Field ThreadPool:TThreadPoolExecutor\r\n    Field ThreadPoolSize:Int\r\n    Field sendMutex:TMutex = CreateMutex()\r\n    \r\n\t' System\r\n\tField capabilities:JNode = New JNode( \"object\", Null )\t' Empty object\r\n\tField handlers:TMap = New TMap\r\n\t\r\n    Method run:Int() Abstract\r\n    Method getRequest:String() Abstract     ' Waits for a message from client\r\n\r\n    Method Close() ; End Method\r\n\r\n\t'V0.0\r\n    Function ExitProcedure()\r\n        'Publish( \"debug\", \"Exit Procedure running\" )\r\n        Publish( \"exitnow\" )\r\n        instance.Close()\r\n        'Logfile.Close()\r\n    End Function\r\n\r\n\t'V0.1\r\n    ' Thread based message receiver\r\n    Function ReceiverThread:Object( data:Object )\r\n        Local lsp:TLSP = TLSP( data )\r\n        Local quit:Int = False     ' Local loop state\r\n\r\n        ' Read messages from Language Client\r\n        Repeat\r\n\r\n            Local node:JNode\r\n                       \r\n            ' Get inbound message from Language Client\r\n            Local content:String = lsp.getRequest()\r\n\r\n            ' Parse message into a JSON object\r\n            Local J:JNode = JSON.Parse( content )\r\n            ' Report an error to the Client using stdOut\r\n            If Not J Or J.isInvalid()\r\n                Local errtext:String = \"ERROR(\"+JSON.errNum+\") \"+JSON.errText+\" at {\"+JSON.errLine+\",\"+JSON.errpos+\"}\"\r\n                ' Send error message to LSP Client\r\n                Publish( \"send\", Response_Error( ERR_PARSE_ERROR, errtext ) )\r\n                Continue\r\n            End If\r\n    \r\n            ' Debugging\r\n            'Local debug:String = JSON.stringify(J)\r\n            'logfile.write( \"STRINGIFY:\" )\r\n            'logfile.write( \"  \"+debug )\r\n   \r\n            ' Check for a method\r\n            node = J.find(\"method\")\r\n            If Not node \r\n                Publish( \"send\", Response_Error( ERR_METHOD_NOT_FOUND, \"No method specified\" ))\r\n                Continue\r\n            End If\r\n            Local methd:String = node.tostring()\r\n            'Publish( \"log\", \"DEBG\", \"RPC METHOD: \"+methd )\r\n            If methd = \"\" \r\n                Publish( \"send\", Response_Error( ERR_INVALID_REQUEST, \"Method cannot be empty\" ))\r\n                Continue\r\n            End If\r\n            ' Validation\r\n            If Not LSP.initialized And methd<>\"initialize\"\r\n                Publish( \"send\", Response_Error( ERR_SERVER_NOT_INITIALIZED, \"Server is not initialized\" ))\r\n                Continue\r\n            End If\r\n                \r\n            ' Transpose JNode into Blitzmax Object\r\n            Local request:TMessage\r\n            Try\r\n                Local typestr:String = \"TMethod_\"+methd\r\n                typestr = typestr.Replace( \"/\", \"_\" )\r\n                typestr = typestr.Replace( \"$\", \"dollar\" ) ' Protocol Implementation Dependent\r\n                'Publish( \"log\", \"DEBG\", \"BMX METHOD: \"+typestr )\r\n                ' Transpose RPC\r\n                request = TMessage( J.transpose( typestr ))\r\n\t\t\t\t' V0.2 - This is no longer a failure as we may have a handler\r\n                'If Not request\r\n                '    Publish( \"log\", \"DEBG\", \"Transpose to '\"+typestr+\"' failed\")\r\n                '    Publish( \"send\", Response_Error( ERR_METHOD_NOT_FOUND, \"Method is not available\" ))\r\n                '    Continue\r\n                'Else\r\n                '    ' Save JNode into message\r\n                '    request.J = J\r\n                'End If\r\n\t\t\t\t' V0.2, Save the original J node\r\n\t\t\t\tIf request request.J = J\r\n            Catch exception:String\r\n                Publish( \"send\", Response_Error( ERR_INTERNAL_ERROR, exception ))\r\n            End Try\r\n\r\n\t\t\t' V0.2\r\n\t\t\t' If Transpose fails, then all is not lost\r\n\t\t\tIf Not request\r\n\t\t\t\trequest = New TMessage( methd, J )\r\n\t\t\tEnd If\r\n    \r\n            ' A Request is pushed to the task queue\r\n            ' A Notification is executed now\r\n            If request.contains( \"id\" )\r\n                ' This is a request, add to queue\r\n                Publish( \"log\", \"DEBG\", \"Pushing request to queue\")\r\n                Publish( \"pushtask\", request )\r\n                'lsp.queue.pushTaskQueue( request )\r\n                Continue\r\n            Else\r\n                ' This is a Notification, execute it now and throw away any response\r\n                Try\r\n                    Publish( \"log\", \"DEBG\", \"Running Notification \"+methd )\r\n                    request.run()\r\n                Catch exception:String\r\n                    Publish( \"send\", Response_Error( ERR_INTERNAL_ERROR, exception ))    \r\n                End Try\r\n            End If\r\n        Until CompareAndSwap( lsp.QuitReceiver, quit, True )\r\n        'Publish( \"debug\", \"ReceiverThread - Exit\" )\r\n    End Function\r\n\r\n\t'V0.1\r\n    ' Thread based message sender\r\n    Function SenderThread:Object( data:Object )\r\n        Local lsp:TLSP = TLSP( data )\r\n        Local quit:Int = False          ' Always got to know when to quit!\r\n        \r\n        'DebugLog( \"SenderThread()\" )\r\n        Repeat\r\n            Try\r\n                'Publish( \"debug\", \"Sender thread going to sleep\")\r\n                WaitSemaphore( lsp.queue.sendcounter )\r\n                'Publish( \"debug\", \"SenderThread is awake\" )\r\n                ' Create a Response from message\r\n                Local content:String = lsp.queue.popSendQueue()\r\n                Publish( \"log\", \"DEBG\", \"Sending '\"+content+\"'\" )\r\n                If content<>\"\"  ' Only returns \"\" when thread exiting\r\n                    Local response:String = \"Content-Length: \"+Len(content)+EOL\r\n                    response :+ EOL\r\n                    response :+ content\r\n                    ' Log the response\r\n                    Publish( \"log\", \"DEBG\", \"Sending:~n\"+response )\r\n                    ' Send to client\r\n                    LockMutex( lsp.sendMutex )\r\n                    StandardIOStream.WriteString( response )\r\n                    StandardIOStream.Flush()\r\n                    UnlockMutex( lsp.sendMutex )\r\n                    'Publish( \"debug\", \"Content sent\" )\r\n                End If\r\n            Catch Exception:String \r\n                'DebugLog( Exception )\r\n                Publish( \"log\", \"CRIT\", Exception )\r\n            End Try\r\n        Until CompareAndSwap( lsp.QuitSender, quit, True )\r\n        Publish( \"debug\", \"SenderThread - Exit\" )\r\n    End Function  \r\n\r\n\t'V0.2\r\n\t' Add a Capability\r\n\t'Method addCapability( capability:String )\r\n\t'\tcapabilities :+ [capability]\r\n\t'End Method\t\r\n\r\n\t'V0.2\r\n\t' Retrieve all registered capabilities\r\n\t'Method getCapabilities:String[][]()\r\n\t'\tLocal result:String[][]\r\n\t'\tFor Local capability:String = EachIn capabilities\r\n\t'\t\tresult :+ [[capability,\"true\"]]\r\n\t'\tNext\r\n\t'\tReturn result\r\n\t'End Method\r\n\r\n\t'V0.2\r\n\t' Add Message Handler\r\n\tMethod addHandler( handler:TMessageHandler, events:String[] )\r\n\t\tFor Local event:String = EachIn events\r\n\t\t\thandlers.insert( event, handler )\r\n\t\tNext\r\n\tEnd Method\r\n\r\n\t'V0.2\r\n\t' Get a Message Handler\r\n\tMethod getMessageHandler:TMessageHandler( methd:String )\r\n\t\tReturn TMessageHandler( handlers.valueForkey( methd ) )\r\n\tEnd Method\r\n\t\r\nEnd Type\r\n\r\n' RESERVED FOR FUTURE EXPANSION\r\nType TLSP_TCP Extends TLSP\r\n    Method Run:Int()\r\n\t\ttextDocument = New TTextDocument\r\n\tEnd Method\r\n    Method getRequest:String() ; End Method\r\nEnd Type\r\n\r\n' StdIO based LSP\r\nType TLSP_Stdio Extends TLSP\r\n\tField StdIn:TStream\r\n\r\n    Method New( threads:Int = 4 )\r\n        Publish( \"info\", \"LSP for BlitzMax NG\" )\r\n        Publish( \"info\", \"V\"+Version+\".\"+build )\r\n        'Log.write( \"Initialised\")\r\n        ' Set up instance and exit function\r\n        instance = Self\r\n        OnEnd( TLSP.ExitProcedure )\r\n        ' Debugstop\r\n        ThreadPoolSize = threads\r\n\t\tThreadPool = TThreadPoolExecutor.newFixedThreadPool( ThreadPoolSize )\r\n        '\r\n        ' Observations\r\n        'Subscribe( [\"\"] )\r\n    End Method\r\n\r\n    Method run:Int()\r\n\t\ttextDocument = New TTextDocument\r\n\r\n        Local quit:Int = False     ' Local loop state\r\n\r\n        ' Open StandardIn\r\n        StdIn = ReadStream( StandardIOStream )\r\n        If Not StdIn\r\n            Publish( \"log\", \"CRIT\", \"Failed to open StdIN\" )\r\n            Return 1\r\n        End If\r\n\r\n        ' Start threads\r\n        Receiver = CreateThread( ReceiverThread, Self )\r\n        Sender = CreateThread( SenderThread, Self )\r\n        'ThreadPool = TThreadPoolExecutor.newFixedThreadPool( ThreadPoolSize )\r\n'DebugStop\r\n        ' Start Message Loop\r\n        Repeat\r\n            ' Fill thread pool\r\n            While ThreadPool.threadsWorking < ThreadPool.maxThreads            \r\n                ' Get next task from queue\r\n\t\t\t\tLocal task:TMessage = queue.getNextTask()\r\n\t\t\t\tIf Not task Exit\r\n\t\t\t\t' Process the event handler\r\n\t\t\t\tThreadPool.execute( New TRunnableTask( task, Self ) )\r\n            Wend\r\n            Delay(100)\r\n        'Until endprocess\r\n        Until CompareAndSwap( lsp.QuitMain, quit, True )\r\n        Publish( \"debug\", \"Mainloop - Exit\" )\r\n        \r\n        ' Clean up and exit gracefully\r\n        AtomicSwap( QuitReceiver, False )   ' Inform thread it must exit\r\n        DetachThread( Receiver )\r\n        Publish( \"debug\", \"Receiver thread closed\" )\r\n\r\n        AtomicSwap( QuitSender, False )     ' Inform thread it must exit\r\n        'PostSemaphore( queue.sendCounter )  ' Wake the thread from it's slumber\r\n        DetachThread( Sender )\r\n        Publish( \"debug\", \"Sender thread closed\" )\r\n\r\n        ThreadPool.shutdown()\r\n        Publish( \"debug\", \"Worker thread pool closed\" )\r\n\r\n        Return exitcode\r\n    End Method\r\n    \r\n    ' Observations\r\n    Method Notify( event:String, data:Object, extra:Object )\r\n    '    Select event\r\n    '    Case \"receive\"\r\n    '        MessageReceiver( string( data ) )\r\n    '    case \"send\"\r\n    '        MessageSender( string( data ) )\r\n    '    End Select\r\n    End Method\r\n\r\n    ' Read messages from the client\r\n    Method getRequest:String()\r\n        Local quit:Int = False     ' Local loop state\r\n        Local line:String   ', char:String\r\n        Local content:String\r\n        Local contentlength:Int\r\n\t\tLocal contenttype:String = \"utf-8\"\r\n\r\n        'Publish( \"log\", \"DEBG\", \"STDIO.GetRequest()\")\r\n        ' Read messages from StdIN\r\n        Repeat\r\n            Try\r\n                line = stdIn.ReadLine()\r\n                If line.startswith(\"Content-Length:\")\r\n                    contentlength = Int( line[15..] )\r\n                    'Publish( \"log\", \"DEBG\", \"Content-Length:\"+contentlength)\r\n                ElseIf line.startswith(\"Content-Type:\")\r\n                    contenttype = Int( line[13..] )\r\n                    ' Backward compatibility, utf8 is no longer supported\r\n                    If contenttype = \"utf8\" contenttype = \"utf-8\"\r\n                    'Publish( \"log\", \"DEBG\", \"Content-Type:\"+contenttype)\r\n                ElseIf line=\"\"\r\n                    'Publish( \"log\", \"DEBG\", \"WAITING FOR CONTENT...\")\r\n                    content = stdIN.ReadString$( contentlength )\r\n                    Publish( \"log\", \"DEBG\", \"Received \"+contentlength+\" bytes:~n\"+content )\r\n                    Return content\r\n                Else\r\n                    Publish( \"log\", \"DEBG\", \"Skipping: \"+line )\r\n                End If\r\n            Catch Exception:String\r\n                Publish( \"critical\", Exception )\r\n            End Try\r\n        'Until endprocess\r\n        Until CompareAndSwap( lsp.QuitMain, quit, True )\r\n    End Method\r\n\r\nEnd Type\r\n\r\nFunction Response_Error:String( code:String, message:String, id:String=\"null\" )\r\n    Publish( \"log\", \"ERRR\", message )\r\n    Local response:JNode = JSON.Create()\r\n    response.set( \"id\", id )\r\n    response.set( \"jsonrpc\", \"2.0\" )\r\n    response.set( \"error\", [[\"code\",code],[\"message\",\"~q\"+message+\"~q\"]] )\r\n    Return response.stringify()\r\nEnd Function\r\n\r\n'   Worker Thread\r\nType TRunnableTask Extends TRunnable\r\n    Field message:TMessage\r\n    Field lsp:TLSP\r\n    Method New( handler:TMessage, lsp:TLSP )\r\n        Self.message = handler\r\n        Self.lsp = lsp\r\n    End Method\r\n    Method run()\r\n\t\tLocal response:String = message.run()\r\n\t\t'V0.2, default to error if nothign returned from handler\r\n\t\tIf response=\"\" response = Response_Error( ERR_METHOD_NOT_FOUND, \"Method is not available\", message.id )\r\n\t\t' Send the response to the client\r\n\t\tPublish( \"sendmessage\", response )\r\n\t\t'lsp.queue.pushSendQueue( response )\r\n\t\t' Close the request as complete\r\n\t\tmessage.state = STATE_COMPLETE\r\n    End Method\r\nEnd Type\r\n\r\n'   Run the Application\r\nPublish( \"log\", \"DEBG\", \"Starting LSP...\" )\r\n\r\n'DebugStop\r\n\r\nTry\r\n    LSP = New TLSP_Stdio( Int(CONFIG[\"threadpool\"]) )\r\n    exit_( LSP.run() )\r\n    'Publish( \"debug\", \"Exit Gracefully\" )\r\nCatch exception:String\r\n    Publish( \"log\", \"CRIT\", exception )\r\nEnd Try\r\n"}}}
